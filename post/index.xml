<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Retriever</title>
    <link>https://sangwoncoco.github.io/post/</link>
    <description>Recent content in Posts on Retriever</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2021–2021, sangwon lee.</copyright>
    <lastBuildDate>Fri, 22 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sangwoncoco.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[LeetCode] Word Break</title>
      <link>https://sangwoncoco.github.io/post/leetcode/20210121-leetcode-139-word-break/</link>
      <pubDate>Fri, 22 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://sangwoncoco.github.io/post/leetcode/20210121-leetcode-139-word-break/</guid>
      <description>
        
          &lt;br/&gt;
---
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;플랫폼&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;LeetCode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;번호&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;139&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;제목&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Word Break&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;유형&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Backtracking, DP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;바로가기&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://leetcode.com/problems/word-break&#34;&gt;LINK&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;문제&#34;&gt;문제&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The same word in the dictionary may be reused multiple times in the segmentation.&lt;/li&gt;
&lt;li&gt;You may assume the dictionary does not contain duplicate words.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;기본-테스트-케이스&#34;&gt;기본 테스트 케이스&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;Input: s = &amp;#34;leetcode&amp;#34;, wordDict = [&amp;#34;leet&amp;#34;, &amp;#34;code&amp;#34;]
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;Output: true
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;Explanation: 
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;  - Return true because &amp;#34;leetcode&amp;#34; can be segmented as &amp;#34;leet code&amp;#34;.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Exapmle 2:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;Input: s = &amp;#34;applepenapple&amp;#34;, wordDict = [&amp;#34;apple&amp;#34;, &amp;#34;pen&amp;#34;]
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;Output: true
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;Explanation: 
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;  - Return true because &amp;#34;applepenapple&amp;#34; can be segmented as &amp;#34;apple pen apple&amp;#34;.
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;  - Note that you are allowed to reuse a dictionary word.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Exapmle 3:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;Input: s = &amp;#34;catsandog&amp;#34;, wordDict = [&amp;#34;cats&amp;#34;, &amp;#34;dog&amp;#34;, &amp;#34;sand&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;cat&amp;#34;]
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;Output: false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;주어진-코드-스니펫&#34;&gt;주어진 코드 스니펫&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;핵심-아이디어-백트래킹&#34;&gt;핵심 아이디어 (백트래킹)&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;문제 살펴보기&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비지 않은 String s와 비지 않은 단어들을 담긴 List&lt;String&gt;들을 가진 wordDict가 메서드의 인자로 주어진다.&lt;/li&gt;
&lt;li&gt;문자열 s가 wordDict 내의 단어들로 깔끔하게 다 쪼개지는지 판단하는 문제이다.&lt;/li&gt;
&lt;li&gt;문자열 s를 쪼개기 위해 wordDict 내의 단어들을 얼마든지 재사용할 수 있다.&lt;/li&gt;
&lt;li&gt;wordDict 내에는 중복되는 단어가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;아이디어&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문자열 s의 0번째 인덱스부터 모든 단어(wordDict 내의 단어들)를 비교해가며 DFS 방식으로 탐색한다.&lt;/li&gt;
&lt;li&gt;만약 탐색 불가능한 경로의 경우 HashMap에 등록한다.&lt;/li&gt;
&lt;li&gt;특정 경로로 진입했을 때 이전에 방문했던 경로라면 더 이상 탐색하는 것이 의미 없으므로 해당 경로의 탐색을 중단한다. (가지치기)&lt;/li&gt;
&lt;li&gt;자세한 설명은 생략한다. 아래 두 예시를 확인하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;첫-번째-예시-답을-찾았을-때&#34;&gt;&lt;em&gt;첫 번째 예시 (답을 찾았을 때)&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_1.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_2.png&#34; alt=&#34;2&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_3.png&#34; alt=&#34;3&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_4.png&#34; alt=&#34;4&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_5.png&#34; alt=&#34;5&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_6.png&#34; alt=&#34;6&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/a_7.png&#34; alt=&#34;7&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;두-번째-예시-답을-찾지-못할-때&#34;&gt;&lt;em&gt;두 번째 예시 (답을 찾지 못할 때)&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_1.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_2.png&#34; alt=&#34;2&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_3.png&#34; alt=&#34;3&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_4.png&#34; alt=&#34;4&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_5.png&#34; alt=&#34;5&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_6.png&#34; alt=&#34;6&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_7.png&#34; alt=&#34;7&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_8.png&#34; alt=&#34;8&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_9.png&#34; alt=&#34;9&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_10.png&#34; alt=&#34;10&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/b_11.png&#34; alt=&#34;11&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실수
&lt;ul&gt;
&lt;li&gt;처음에 백트래킹 방식이 아닌 단순 DFS로 완전 탐색 했다.&lt;/li&gt;
&lt;li&gt;이 경우 아래와 같은 테스트 케이스에서 TLE가 발생한다.&lt;/li&gt;
&lt;li&gt;이를 해결하기 위해 이미 한 번 방문했던 경로를 기록해뒀다가 매번 특정 경로에 진입할 때 마다 방문 이력이 있는 경로인지 확인함으로써 최적화 해야 할 필요성을 느껴 backtracking 기법을 적용했다.
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-JAVA&#34; data-lang=&#34;JAVA&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Last&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;executed&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab&amp;#34;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaaaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;그래서 HashMap을 활용해 메모이제이션 역할을 수행하도록 하였다.&lt;/li&gt;
&lt;li&gt;다음부터는 DFS 방식의 완전 탐색 시에 항상 최적화(backtracking 적용)를 염두해 두어야 겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;구현-코드-백트래킹&#34;&gt;구현 코드 (백트래킹)&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;    
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;backtrack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;());&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;    
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;backtrack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;failResStrMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 이미 한 번 거쳤던 경로 라면? return false
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;failResStrMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 문자열이 완벽히 다 쪼개졌다면? return true (정답)
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 완탐 (dfs)
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 다음에 탐색할 문자열 범위가 유효하다면? 그리고 다음에 탐색할 문자열이 리스트 내에 존재한다면? 탐색 시작
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backtrack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;failResStrMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// backtrack() 함수 호출 결과가 true라면 정답을 찾은 것이므로 탐색 종료
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                        &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;                        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 해당 경로로 탐색 했으나 정답을 찾지 못했다면?(ret == false인 경우)
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 가지치기를 위해서 해당 경로를 fail 경로(재탐색하면 안되는 경로)로 등록
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;31&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;failResStrMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;32&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;33&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;34&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;35&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;36&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;아이디어-dp-feat-틀림-자세한-건-아래에서-설명&#34;&gt;아이디어 (DP) (feat. 틀림, 자세한 건 아래에서 설명)&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;dp
&lt;ul&gt;
&lt;li&gt;dp[i] == true 의미
&lt;ul&gt;
&lt;li&gt;문자열 s의 substring(0~i)을 완벽히 다 쪼갤 수 있음을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;점화식
&lt;ul&gt;
&lt;li&gt;dp[i] = dp[t] &amp;amp;&amp;amp; wordSet.contains(s.substring(t, i))&lt;/li&gt;
&lt;li&gt;sub problem: dp[t]&lt;/li&gt;
&lt;li&gt;super problem: dp[i]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;시간 복잡도 O(n+k)로 풀 수 있다
&lt;ul&gt;
&lt;li&gt;n: 문자열의 길이&lt;/li&gt;
&lt;li&gt;k: 단어의 개수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_init.png&#34; alt=&#34;init&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_1.png&#34; alt=&#34;1&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_2.png&#34; alt=&#34;2&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_3.png&#34; alt=&#34;3&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_4.png&#34; alt=&#34;4&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_5.png&#34; alt=&#34;5&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_6.png&#34; alt=&#34;6&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_7.png&#34; alt=&#34;7&#34;&gt;
&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210121-leetcode-139/dp_8.png&#34; alt=&#34;8&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;구현-코드-dp&#34;&gt;구현 코드 (DP)&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/word-break/discuss/821032/JAVA-DP-Solution-in-Detail-for-Beginner&#34;&gt;다른 사람의 코드&lt;/a&gt;(O(n^2) 시간 복잡도)를 O(n+k)로 최적화 시켜 보았다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;wordBreak&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;word&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wordDict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;word&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;contains&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;            
&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()];&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;근데 아래의 테스트 케이스에서 답을 도출하는데 실패했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaaaaa&amp;#34;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;aaa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;이유는 앞에서 부터 길이가 짧은 substring부터 set에 존재하는지 확인하기 때문에 이 경우는 &amp;quot;aaa_aaa_a&amp;quot;로 분할된다.&lt;/li&gt;
&lt;li&gt;&amp;quot;링크에서 제시된 코드를 최적화 할 수 있다&amp;quot;라고 생각했다.&lt;/li&gt;
&lt;li&gt;생각한건 문제가 되지 않는다.&lt;/li&gt;
&lt;li&gt;문제는 그 이후의 나의 행동이다.&lt;/li&gt;
&lt;li&gt;코드를 최적화 시킬 수 있다고 확신하고 블로그에 업로드 할 ppt를 먼저 만드는게 아니라 아이디어가 유효한지 검증하는 과정이 우선됐어야 했다.&lt;/li&gt;
&lt;li&gt;이건 굉장히 안좋은 습관이다. 내가 가진 생각, 아이디어를 나 스스로 의심하지 않고 있다는 방증이다.&lt;/li&gt;
&lt;li&gt;이러한 습관은 단순한 시간 낭비 뿐 만 아니라 어떤 경우는 나 혹은 누군가에게 굉장히 크리티컬한 영향을 미칠 수 있다는 사실을 명심하자.&lt;/li&gt;
&lt;li&gt;다시 본론으로 돌아가자면...&lt;/li&gt;
&lt;li&gt;결국은 가장 긴 substring 부터 set에 존재하는지 확인하기 위해 O(n^2)으로 구현해야 한다.&lt;/li&gt;
&lt;li&gt;그게 아니라면 문자열 맨 앞에서부터 매번 가장 길이가 긴 문자열 부터 차례로 비교해주는 방식으로 구현할 수도 있다. 이때 시간 복잡도는 O(n*k)가 되며 k가 n보다 클 경우 O(n^2) 보다 느리다.&lt;/li&gt;
&lt;li&gt;다음부터는 ppt 먼저 만들지 말고 내가 생각한 아이디어가 유효한지 코드 부터 짜서 돌려보고 정답을 도출할 수 있는 아이디어라면 그때 ppt로 만들어야 겠다. ㅠㅠㅠ&lt;/li&gt;
&lt;li&gt;&lt;em&gt;그래도 좋은 시도였다. 막연히 &amp;quot;O(n) 솔루션으로 풀 수 있는데...&amp;quot; 라고 생각만 했다면 이런 경우의 테스트 케이스를 통과하지 못한다는 사실을 인지하지 못했을 테니까 말이다.&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;후기&#34;&gt;후기&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;사실 이 문제를 푼 이유는 DP 유형을 연습하기 위해서였다.&lt;/li&gt;
&lt;li&gt;그러나 DP로는 해결 방법이 보이지 았았다.&lt;/li&gt;
&lt;li&gt;근데 DFS 방식으로 구현하면 답을 도출할 수 있을 것 같아 DFS로 구현했고 TLE가 발생했다.&lt;/li&gt;
&lt;li&gt;원인은 이미 한 번 방문했던 경로도 계속해서 반복 탐색하기 때문에 비효율적이였다.&lt;/li&gt;
&lt;li&gt;그래서 이미 한 번 탐색을 진행했으나 단어를 완벽히 쪼갤 수 없었던 경로를 HashMap에 저장했다. (지금 생각해보니 특정 경로로 진입했을 때의 문자열만 저장하면 되니 HashMap이 아닌 HashSet이 적합할 듯 하다.)&lt;/li&gt;
&lt;li&gt;그리고 매번 특정 경로에 진입할 때 마다 이미 방문 이력이 있던 경로인지 확인하고 만약 이미 방문했다면 더 이상 해동 경로를 탐색하지 않도록 backtracking 기법을 적용함으로써 TLE를 해결했다.&lt;/li&gt;
&lt;li&gt;문제를 해결한 후 다른 사람들의 DP 솔루션을 보니 사고 방식이 신기했다.&lt;/li&gt;
&lt;li&gt;나는 문자열 s를 단어 단위, 즉 sub word 단위로 쪼갤려고 생각했는데 다른 사람들은 하나의 문자 단위로 쪼개서 super problem과 sub problem으로 나누고 점화식을 도출한 것이다.&lt;/li&gt;
&lt;li&gt;이는 내가 생각할 수 있는 기존의 사고 방식과는 거리가 멀어서 신선한 충격을 받았다.&lt;/li&gt;
&lt;/ul&gt;

        
      </description>
    </item>
    
    <item>
      <title>equals()와 hashcode()</title>
      <link>https://sangwoncoco.github.io/post/java/20210121-java-equals-and-hashcode/</link>
      <pubDate>Thu, 21 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://sangwoncoco.github.io/post/java/20210121-java-equals-and-hashcode/</guid>
      <description>
        
          &lt;!-- page parameters, https://github.com/chipzoller/hugo-clarity#page-parameters --&gt;
&lt;!-- command: hugo new {archetypes}/{path...}/{post-name.md} --&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;본-포스팅은-아래-내용에-대한-지식이-있어야-이해할-수-있는-내용-입니다&#34;&gt;본 포스팅은 아래 내용에 대한 지식이 있어야 이해할 수 있는 내용 입니다.&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Java의 메모리 모델
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yaboong.github.io/java/2018/05/26/java-memory-management/&#34;&gt;만약 모르신다면?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash 자료구조와 그와 관련된 hash function, hash key, bucket 등의 용어에 대한 이해
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Vi0hauJemxA&amp;amp;ab_channel=%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD&#34;&gt;만약 모르신다면?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;목차&#34;&gt;목차&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;목적&lt;/li&gt;
&lt;li&gt;equals() 기본 동작&lt;/li&gt;
&lt;li&gt;equals()를 오버라이딩 하는 이유&lt;/li&gt;
&lt;li&gt;hashcode() 존재 이유와 기본 동작&lt;/li&gt;
&lt;li&gt;equals()와 hashcode()는 계약 관계에 있다&lt;/li&gt;
&lt;li&gt;equals()만 오버라이딩 했을 때의 동작 (계약 위반)&lt;/li&gt;
&lt;li&gt;Hash Based Implementation에서 hashcode()를 어떻게 활용하는지 확인해보자&lt;/li&gt;
&lt;li&gt;hashcode()를 오버라이딩 하는 다양한 방법&lt;/li&gt;
&lt;li&gt;난 이 객체 절대 Hash Based Implementaion의 Key로 사용 안할건데?&lt;/li&gt;
&lt;li&gt;결론&lt;/li&gt;
&lt;li&gt;Follow Ups&lt;/li&gt;
&lt;li&gt;References&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;목적&#34;&gt;목적&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Java에서 equals()와 hashcode()의 기본 동작을 이해한다.&lt;/li&gt;
&lt;li&gt;왜 equals()와 hashcode()의 계약을 이해한다.&lt;/li&gt;
&lt;li&gt;equals()와 hashcode()의 계약 위반 시 발생하는 문제를 살펴본다.&lt;/li&gt;
&lt;li&gt;Hash Based Implementation에서 hashcode()를 활용하는지 직접 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;equals-기본-동작&#34;&gt;equals() 기본 동작&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// equals() 구현 코드
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;위 코드는 Object 클래스에 구현된 equals()의 구현 내용 이다.&lt;/li&gt;
&lt;li&gt;인자로 받은 참조 주소와 자신의 주소(this)를 비교해서 같다면 true를 반환하는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;여기서 중요한 포인트는 Object 클래스는 모든 객체들의 최상위 조상이다. 그러므로 Java의 모든 클래스들은 Object로 부터 상속 받은 equals()를 포함하고 있으며 따로 오버라이딩 하지 않는 이상 equals()의 동작은 Object 클래스의 기본 동작과 동일하다.&lt;/li&gt;
&lt;li&gt;그렇다면 equals()의 존재 목적은 무엇일까?
&lt;ul&gt;
&lt;li&gt;당연하게도 객체의 관계가 동등한지를 판단하기 위해서이다.&lt;/li&gt;
&lt;li&gt;아래는 JDK8 문서에 작성된 있는 equals()의 5가지 특징이다. equals()는 반드시 아래의 특징을 지키도록 구현해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;reflexive (반사성)
&lt;ul&gt;
&lt;li&gt;null이 아닌 참조 x가 있을 때&lt;/li&gt;
&lt;li&gt;x.equals(x) -&amp;gt; true 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;symmetric (대칭성)
&lt;ul&gt;
&lt;li&gt;null이 아닌 참조 x, y가 있을 때&lt;/li&gt;
&lt;li&gt;만약 x.equals(y) -&amp;gt; true 라면&lt;/li&gt;
&lt;li&gt;y.equals(x) -&amp;gt; true 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;transitive (전이성)
&lt;ul&gt;
&lt;li&gt;null이 아닌 참조 x, y, z가 있을 때&lt;/li&gt;
&lt;li&gt;만약 x.equals(y) -&amp;gt; true 이고&lt;/li&gt;
&lt;li&gt;y.equals(z) -&amp;gt; true 라면&lt;/li&gt;
&lt;li&gt;x.equals(z) -&amp;gt; true 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;consistent (일관성)
&lt;ul&gt;
&lt;li&gt;null이 아닌 참조 x, y가 있을 때&lt;/li&gt;
&lt;li&gt;객체 비교에 사용된 정보가 수정되지 않은 경우에&lt;/li&gt;
&lt;li&gt;x.equals(y)는 항상 일관성 있는 결과 값을 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;null이 아닌 참조 x가 있을 때, x.equals(null) -&amp;gt; false 이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;equals를-오버라이딩-하는-이유&#34;&gt;equals()를 오버라이딩 하는 이유&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍을 하다 보면 equals()를 오버라이딩 해야할 때가 있다. (&lt;em&gt;많다.&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;두 객체가 참조하는 인스턴스의 레퍼런스(주소)를 비교하는 것이 아닌 실제 객체 인스턴스를 구성하는 멤버 변수들의 값들을 비교하여 두 객체의 동등성을 판단하고 싶은 경우가 이 경우다.&lt;/li&gt;
&lt;li&gt;대표적인 예로 문자열을 비교하는 경우를 생각해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;aa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;aa&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;equals&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;프로그래머는 객체가 참조하고 있는 인스턴스의 실제 내용인 a(&amp;quot;aa&amp;quot;)와 b(&amp;quot;aa&amp;quot;)를 비교하고 싶다.&lt;/li&gt;
&lt;li&gt;그러나 Object에 구현된 equals()의 기본 동작은 두 객체의 레퍼런스를 비교하는 것이다.&lt;/li&gt;
&lt;li&gt;그러므로 a(&amp;quot;aa&amp;quot;)와 b(&amp;quot;aa&amp;quot;)를 비교하는 것이 아닌 각 객체가 참조하고 있는 레퍼런스를 비교할 것이다.&lt;/li&gt;
&lt;li&gt;그렇기 때문에 프로그래머는 자신의 입맞에 맞게 equals()를 오버라이딩 해줘야 한다.&lt;/li&gt;
&lt;li&gt;위 코드는 a, b 2개의 String을 비교하는 코드인데 놀랍게도 조건문의 결과가 true로 판명나 &amp;quot;equals&amp;quot;가 출력된다.&lt;/li&gt;
&lt;li&gt;그 이유는 JDK에 구현된 String 클래스에서 equals()를 미리 오버라이딩 해뒀기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// String 클래스에서 오버라이딩된 equals()
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anObject&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aString&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anObject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;coder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;coder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;isLatin1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringLatin1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;                              &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StringUTF16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;위는 String 클래스에서 오버라이딩된 equals()의 구현이다.&lt;/li&gt;
&lt;li&gt;어떤 사람은 구현 내용 중 첫 번째 조건문을 보고 &amp;quot;뭐야? this == anObject? 자신과 똑같은 참조를 비교하네 Object랑 다른게 뭐지?&amp;quot; 라고 생각할 수 있을 것 같다.&lt;/li&gt;
&lt;li&gt;근데 잘 생각해보자. 자신과 같은 주소를 가리키는 객체라면 그 내용도 같을 것이다.&lt;/li&gt;
&lt;li&gt;즉, 주소가 같다면 자기 자신을 자기 자신과 비교하는 것일테니 뒤에 내용은 확인할 필요 조차 없다는 것이다.&lt;/li&gt;
&lt;li&gt;본격적으로 두 개체의 내용이 같은지를 비교하는 것은 3번째 조건문 부터 이다.
&lt;ul&gt;
&lt;li&gt;본 포스팅에서는 String에 구현된 equals()의 구현 내용을 더 까보진 않는다.
&lt;ul&gt;
&lt;li&gt;이 이상 내부 구현을 파봤자 native 메서드는 나오지 않으니 String에 구현된 equals()의 실제 구현은 눈으로 다 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;그러니 그 이상의 구현 내용이 궁굼하다면 본인이 직접 살펴보도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;중요한 포인트는 String 클래스의 equals()는 Object 클래스에 구현된 equals()의 기본 동작을 피하기 위해 오버라이딩 되었다는 것이다.&lt;/li&gt;
&lt;li&gt;즉 프로그래머가 정의한 클래스의 equals()도 Object 클래스의 equals() 기본 동작을 피하기 위해서는 입맞에 맞게 오버라이딩 해야 한다는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;hashcode-존재-이유와-기본-동작&#34;&gt;hashcode() 존재 이유와 기본 동작&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Object 클래스에 hashcode()가 정의돼 있기에 모든 객체는 hashcode()를 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;그렇다면 hashcode()는 도대체 어떤 목적을 위해서 존재하길래 모든 객체가 사용할 수 있게 디자인된 것일까?&lt;/li&gt;
&lt;li&gt;우선 JDK 문서와 구현 내용을 살펴보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;생략...
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (The hashCode may or may not be implemented as some function of an object&amp;#39;s memory address at some point in time.)
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;Returns:
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;a hash code value for this object.
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@HotSpotIntrinsicCandidate&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;native&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hashCode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;아쉽게도 hashcode()는 native 메서드 이기에 상세 구현 내용은 살펴볼 수 없었다.
&lt;ul&gt;
&lt;li&gt;구현 내용이 궁굼하다면? &lt;a href=&#34;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp#l601&#34;&gt;Here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그러나 위 주석만으로 hashcode()의 역할과 용도를 파악하기에는 충분하다.
&lt;ul&gt;
&lt;li&gt;[역할] Returns a hash code value for the object.
&lt;ul&gt;
&lt;li&gt;해당 객체를 위한 hash code를 계산하고 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;[용도] This method is supported for the benefit of hash tables such as those provided by java.util.HashMap.
&lt;ul&gt;
&lt;li&gt;Hash Based Implementation(HashMap, HashTable, HashSet, 등)들을 위해 지원되는 메서드이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;역할&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;hash code를 계산하고 반환하는 것은 알겠는데 여기서 의문점이 한 가지 생긴다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;quot;hash code를 계산해내는 기준이 뭐지?&amp;quot;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;hashcode()가 hash code를 계산해내는 기본 방식은 객체 인스턴스가 위치해 있는 메모리 주소이다. (자세한 내용은 위 native 메서드를 까보아야 하는데.. 난 포기다..)&lt;/li&gt;
&lt;li&gt;각 객체 인스턴스는 고유한 메모리 주소를 가지기에 각 객체 인스턴스의 hash code는 고유한 값이란 것을 알 수 있다.&lt;/li&gt;
&lt;li&gt;뒤에서 다루겠지만 Java 언어는 hashcode()를 오버라이딩할 수 있도록 설계 되었다.&lt;/li&gt;
&lt;li&gt;hashcode()의 수행 결과 리턴 값은 고유한 값을 반환해야 하는데 왜 Java 언어는 프로그래머가 hashcode()를 오버라이딩 해서 프로그래머가 기본 동작을 오염시킬 여지를 남기도록 설계한 것일까?&lt;/li&gt;
&lt;li&gt;그 이유는 hashcode()는 equals()와 계약 관계에 있으며 이 계약은 Hash Based Implementation과 관련이 있으니 기억해 두고 있기 바란다.&lt;/li&gt;
&lt;li&gt;또한 프로그래머가 이 계약을 위반 시 컴파일 시에 잡아주는 것은 아니며 안전한 소프트웨어를 개발하기 위해 Java 언어에서 권고하는 계약 정도라고 알아두면 좋을 듯하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;용도&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;주석에 따르면 hashcode()는 &amp;quot;Hash Based Implementation(HashMap, HashTable, HashSet)들을 위해 지원되는 메서드&amp;quot;라고 한다.&lt;/li&gt;
&lt;li&gt;이 문장을 이해하기 위해서는 아래 내용들을 알고 있어야 하는데 이 내용은 해당 포스팅의 범주를 벗어나므로 다루지 않는다.
&lt;ul&gt;
&lt;li&gt;Hash 자료구조&lt;/li&gt;
&lt;li&gt;Java에서 Hash Based Implementation(HashMap, HashTable, HashSet, 등)이 Hash 자료구조를 기반으로 동작한다는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;다시 본 내용으로 돌아와서 이야기를 계속하자면&lt;/li&gt;
&lt;li&gt;hashcode()를 이용해서 객체의 고유한 hash code를 얻어내고 이 값을 Hash Based Implementation의 Key 값으로 사용하겠다는 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;즉 &amp;quot;hashcode()는 Hash Based Implementation의 key를 계산하기 위해 존재한다.&amp;quot;라고 할 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;equals와-hashcode는-계약-관계에-있다&#34;&gt;equals()와 hashcode()는 계약 관계에 있다&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;본 내용을 설명하기 이전에 우선 &lt;strong&gt;계약&lt;/strong&gt;에 대해서 잠시 설명하겠다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 언어에서 계약이란게 무슨 의미일까?
&lt;ul&gt;
&lt;li&gt;상세한 의미는 나도 잘 모르겠다. 그러나 나는 아래와 같이 이해하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;quot;계약이란 프로그래머가 이것을 어길 시 컴파일 시점에 잡아주지는 않으나 런타임 시에 발생할 수 있는 문제를 예방하기 위해(즉, 안전한 소프트웨어를 개발하기 위해) 지켜야 하는 사항&amp;quot;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;나는 위에서 &lt;strong&gt;계약&lt;/strong&gt;을 &amp;quot;런타임 시에 발생할 수 있는 문제를 예방하기 위해 지켜야 하는 것이며 계약을 따르는 것은 안전한 소프트웨어를 개발하는 것에 기여한다.&amp;quot;라고 정의 했다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;그러면 아래와 같은 의문이 들 것이다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;equals()와 hashcode()는 어떤 계약 관계에 있는가?&lt;/li&gt;
&lt;li&gt;이 계약을 지키는 것이 어떻게 안전한 소프트웨어를 만드는데 기여 하는가?&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;우선 1번 의문을 풀기 위해 어떤 계약인지 살펴보자.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;The general contract of hashCode is:
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;- Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;- If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;- It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;너무 길다. 간단하게 요약하자면 아래와 같다. (&lt;strong&gt;사실 요약도 전혀 간단하지 않다&lt;/strong&gt;)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;java application 실행 중, 객체 A의 equals()를 위해 사용되는 정보가 바뀌지 않은 경우 hashcode() 호출 결과는 항상 같다.&lt;/li&gt;
&lt;li&gt;두 객체가 equals()에 의해 동등함이 증명된다면, 두 객체에서 hashcode()를 호출 했을 때 결과 값은 항상 같다.&lt;/li&gt;
&lt;li&gt;두 객체가 equals()에 의해 동등함이 증명되지 않는다면, 두 객체 각자 hashcode()를 호출 했을 때 결과 값이 항상 다를순 없다.
&lt;ul&gt;
&lt;li&gt;이 경우 hashcode() 결과 값이 완전 달라야 한다고 생각할 수 있지만 hashcode의 범위는 자료형의 범위에 한정돼 있기에 다른 고유한 객체로 부터 동일한 hash code가 생성되는 경우도 있다.&lt;/li&gt;
&lt;li&gt;이 경우 &amp;quot;그러면 Key 값이 충돌하는 건데 어떻게 Hash Based Implementation에 저장할 수 있는 거지?&amp;quot;라고 생각할 수 있는데&lt;/li&gt;
&lt;li&gt;이를 이해하기 위해서는 Hash 자료구조의 &lt;strong&gt;충돌&lt;/strong&gt;에 대한 이해가 필요하다. 이 내용 역시 본 포스팅에서는 다루지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;즉
&lt;ul&gt;
&lt;li&gt;equals()로 인해 두 객체의 동등함이 증명된다면 두 객체의 hashcode() 호출 결과는 반드시 같다.&lt;/li&gt;
&lt;li&gt;그러나 동등함이 증명되지 않는다고 반드시 두 객체의 hashcode() 호출 결과가 다른건 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이제 2번 의문을 풀어보자. 그런데 이 의문을 풀기 이전에 아래 내용을 이해해야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;equals()를 오버라이딩 하는 프로그래머의 의도
&lt;ul&gt;
&lt;li&gt;위에서 다룬 &lt;em&gt;equals() 기본 동작&lt;/em&gt;, &lt;em&gt;equals()를 오버라이딩 하는 이유&lt;/em&gt; 파트에서도 살펴봤듯 우리는 아래와 같은 사실을 알고 있다.&lt;/li&gt;
&lt;li&gt;프로그래머가 정의한 클래스는 equals()를 가지고 있으며 이것을 따로 오버라이딩 하지 않는 이상 Object 클래스에 정의된 대로 동작한다.&lt;/li&gt;
&lt;li&gt;그러므로 equals()를 오버라이딩 하는 이유는 같은 타입을 가진 두 객체의 동등성을 판단하는 기준을 수정하기 위해서이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;quot;hashcode()의 결과 값은 Hash Based Implementation의 동작에 영향을 끼친다&amp;quot;는 사실
&lt;ul&gt;
&lt;li&gt;hashcode()의 결과 값은 객체 자신에 대한 hash code이다.&lt;/li&gt;
&lt;li&gt;hashcode()의 결과 값은 Hash Based Implementation의 Key값으로 사용된다.&lt;/li&gt;
&lt;li&gt;hashcode()의 기본 동작은 오버라이딩될 수 있다.&lt;/li&gt;
&lt;li&gt;hashcode()의 결과 값은 Hash Based Implementation의 동작에 영향을 미친다.&lt;/li&gt;
&lt;li&gt;계약을 지키지 않거나 hashcode()를 잘못된 방식으로 오버라이딩 할 경우 Hash Baesd Implementation의 동작에 악영향을 끼친다.
&lt;ul&gt;
&lt;li&gt;이 악영향으로 인해 프로그램이 오동작하게 만든다.&lt;/li&gt;
&lt;li&gt;즉 불안전한 소프트웨어를 만들게 된다.&lt;/li&gt;
&lt;li&gt;이에 대한 예시는 다음 파트인 *equals()만 오버라아딩 했을 때의 동작 (계약 위반)*에서 다룬다.
&lt;ul&gt;
&lt;li&gt;참고로 equals(), hahscode() 모두 오버라이딩 했지만 hashcode()를 잘못 오버라이딩 한 경우도 계약 위반에 해당한다. 그러나 본 포스팅에서는 이에 대한 내용은 다루지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;equals만-오버라이딩-했을-때의-동작-계약-위반&#34;&gt;equals()만 오버라이딩 했을 때의 동작 (계약 위반)&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getAge&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uobj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uobj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uobj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getAge&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;31&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;32&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;33&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;App&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;34&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;35&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;36&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hashmap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;37&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;38&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;danbi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;danbi&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;27&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;39&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fakeDanbi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;danbi&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;27&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;40&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;41&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;danbi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fakeDanbi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;42&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;같다&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;43&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;44&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;45&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;hashmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;danbi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;46&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;hashmap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fakeDanbi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;47&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;48&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;end...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;49&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;50&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;위 예제 실행 시 콘솔에 **&amp;quot;같다&amp;quot;**가 출력된다.&lt;/li&gt;
&lt;li&gt;왜냐하면 danbi와 fakeDanbi의 메모리 주소는 다르지만 User 클래스에서 equals()를 입맞에 맞게 오버라이딩 했기 때문이다.&lt;/li&gt;
&lt;li&gt;이때 프로그래머는 프로그램 내에서 User 객체의 name과 age 두 필드만 같은 값을 가진다면 두 객체는 동등하게 판명나도록 equals()를 오버라이딩했다.&lt;/li&gt;
&lt;li&gt;그러면 이 두 객체를 hashmap에 삽입하면 어떻게 동작해야 할까?&lt;/li&gt;
&lt;li&gt;당연히 계약에 의거하여 두 객체는 같은 hash code를 가지며 hashmap 내의 같은 버킷에 중복 삽입되어야 한다.&lt;/li&gt;
&lt;li&gt;그러나 디버거를 통해 메모리를 살펴보면 hashmap은 아래 상태를 가진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/java/20210121-Java-equals-and-hashcode/hashmap_state.png&#34; alt=&#34;HashMap State&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분명 두 객체는 프로그램 상에서 동일하게 판명 되어야 하며 Hash Based Implementation의 동일한 버킷에 데이터가 삽입 되어야 한다.&lt;/li&gt;
&lt;li&gt;그러나 프로그램 상에서 동일하다고 판명난 두 객체 danbi와 fakeDanbi는 HashMap의 다른 버킷에 삽입돼 자리잡고 있다.&lt;/li&gt;
&lt;li&gt;이런 현상이 발생한 이유는 프로그래머가 equals()와 hashcode()의 계약을 위반했기 때문이다.&lt;/li&gt;
&lt;li&gt;Object 클래스에 구현된 equals()와 hashcode()의 기본 동작은 계약을 준수하고 있는 상태이다.&lt;/li&gt;
&lt;li&gt;그러나 프로그래머가 만든 User 클래스는 equals()의 기본 동작을 자신의 입맞에 맞게 오버라이딩 했지만 hashcode()는 Object 클래스의 기본 동작을 따른다.&lt;/li&gt;
&lt;li&gt;즉 User 클래스는 equals()와 hashcode()의 계약을 위반하고 있는 상태이며 이는 프로그램이 예상치 못한 동작을 한 원흉이 된 것이다.&lt;/li&gt;
&lt;li&gt;이러한 현상을 해결하기 위해선 계약을 준수하도록 hashcode()를 올바른 방법으로 오버라이딩 해줘야 한다.
&lt;ul&gt;
&lt;li&gt;본 포스팅에서는 hashcode()를 올바르게 오버라이딩 하는 방법에 대해서는 다루지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;hash-based-implementation에서-hashcode를-어떻게-활용하는지-확인해보자&#34;&gt;Hash Based Implementation에서 hashcode()를 어떻게 활용하는지 확인해보자&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;HashMap 클래스의 put() 메서드의 일부를 살펴보며 정말 hashcode()를 활용하여 버켓의 Key 값을 얻어내는지 확인해보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/java/20210121-Java-equals-and-hashcode/stackframe.png&#34; alt=&#34;stackframe&#34;&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/java/20210121-Java-equals-and-hashcode/use_hashcode.png&#34; alt=&#34;hashcode&#34;&gt;&lt;/p&gt;
&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;첫 번째 사진은 두 번째 사진에 왔을 때의 stack frame이다.&lt;/li&gt;
&lt;li&gt;stack frame 확인 결과 main()에서 HashMap 클래스의 put()을 호출했고 put()에서 hash()를 호출한다.&lt;/li&gt;
&lt;li&gt;그리고 두 번째 사진을 보시면 hash()에서는 Object key를 인자로 받아 key에서 hashcode()를 호출하는 것을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;이제 정말 여기서 만든 key를 활용하여 데이터를 삽입하는지 살펴보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;putVal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;onlyIfAbsent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;                   &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;evict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 1. 테이블이 null이거나 길이가 0일 때 테이블 크기를 초기화 혹은 리사이징 하는 작업
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;resize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 2. 버킷이 null인 경우 새로운 노드 삽입
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 3. 버킷이 null이 아닌 경우 이미 해당 버킷에 노드가 들어가 있으니 충돌 회피를 하는 듯하다?
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;                &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))))&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TreeNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TreeNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;putTreeVal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;binCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;                        &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;                        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;binCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TREEIFY_THRESHOLD&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// -1 for 1st
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                            &lt;span class=&#34;n&#34;&gt;treeifyBin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tab&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt;                        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt;                        &lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))))&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt;                        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;31&lt;/span&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;32&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;33&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// existing mapping for key
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;34&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;35&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;onlyIfAbsent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;36&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;37&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;afterNodeAccess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;38&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;39&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;40&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;41&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;modCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;42&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threshold&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;43&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;resize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;44&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;afterNodeInsertion&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;evict&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;45&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;46&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;putVal()은 hash() 종료 이후 put()에서 호출하는 메서드이다.&lt;/li&gt;
&lt;li&gt;모든 코드를 살펴볼 순 없고 주석 1, 2, 3만 간단하게 살펴보자. (&lt;em&gt;이 모든 것은 나의 추측일 뿐 이다..&lt;/em&gt;)
&lt;ol&gt;
&lt;li&gt;테이블이 null이거나 길이가 0일 때 테이블 크기를 초기화 혹은 리사이징 하는 작업인 듯 하다.&lt;/li&gt;
&lt;li&gt;노드를 삽입하려는 버킷이 null인 경우 해당 버킷은 비어있는 상태를 뜻하니 새로운 노드를 만들어 바로 삽입하는 코드인 듯 하다.&lt;/li&gt;
&lt;li&gt;노드를 삽입하려는 버킷이 null이 아니기에(이미 어떤 노드가 삽입된 상태를 뜻한다.) 충돌이 발생하므로 충돌 회피를 위해 특정 작업을 수행하는 코드인 듯 하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;위-코드에-대한-설명은-지극히-나의-추측일-뿐이라는-것을-명심하자&#34;&gt;&lt;em&gt;위 코드에 대한 설명은 지극히 나의 추측일 뿐이라는 것을 명심하자.&lt;/em&gt;&lt;/h3&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;hashcode를-오버라이딩하는-다양한-방법&#34;&gt;hashcode를 오버라이딩하는 다양한 방법&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;간편하게 hashcode()를 오버라이딩하는 몇 가지 방법에 대해 언급하겠다.
&lt;ol&gt;
&lt;li&gt;IDE Support&lt;/li&gt;
&lt;li&gt;lombok&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang&lt;/li&gt;
&lt;li&gt;org.apache.commons.lang3&lt;/li&gt;
&lt;li&gt;com.google.guava&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;난-이-객체-hash-based-implentation의-key-값으로-절대-사용하지-않을건데&#34;&gt;난 이 객체 Hash Based Implentation의 Key 값으로 절대 사용하지 않을건데?&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;의도했든 의도치 않든 하지 말라는데 하는 청개구리 같은 사람은 항상 존재한다.&lt;/li&gt;
&lt;li&gt;의도적으로 그렇게 하는 그들의 근거는 &amp;quot;내가 만든 객체는 Hash Based Implementation의 Key 값으로 절대 사용 안할건데?&amp;quot; 이다.&lt;/li&gt;
&lt;li&gt;혼자 만드는 소프트웨어이고 그것을 당신 혼자 사용할 거라면 상관 없다. 마음데로 해라.&lt;/li&gt;
&lt;li&gt;그러나 회사에서 소프트웨어를 만드는 것이라면 절대 그렇게 하지말았으면 한다.&lt;/li&gt;
&lt;li&gt;최초에 당신이 그 코드를 짰더라도 당신이 그 회사에서 그 소프트웨어의 명운이 다할 때 까지 있을거란 보장도 없을 뿐 더러 그렇다 하더라도 평생 혼자 작업할게 아니지 않은가.&lt;/li&gt;
&lt;li&gt;누군가가 실수로 계약을 위반한 객체를 Hash Based Implementation의 Key 값으로 사용하여 장애의 원인이 된다면? 그래서 회사에 악영향을 끼친다면?&lt;/li&gt;
&lt;li&gt;그리고 그 소프트웨어를 개발하는 당신도 같은 실수를 하지 않을거라고 장담할 수 없다.&lt;/li&gt;
&lt;li&gt;그렇기에 이 계약을 위반하는 것은 시스템에서 언제 터질 지 모르는 지뢰를 설치해 놓은 것이나 다름없단 사실을 명심하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;결론&#34;&gt;결론&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;equals()와 hashcode()는 계약 이다.
&lt;ul&gt;
&lt;li&gt;equals() 오버라이딩 시 hashcode()도 올바른 방법으로 오버라이딩 해주도록 하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 계약을 위반하는 것은 소프트웨어에 잠재적인 버그를 심어 놓은 것이나 다름 없단 사실을 명심하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;follow-ups&#34;&gt;Follow Ups&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;hashcode()를 올바르게 오버라이딩하는 규칙&lt;/li&gt;
&lt;li&gt;native method인 hashcode() 작동 방식&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html&#34;&gt;https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java&#34;&gt;https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Vi0hauJemxA&amp;amp;ab_channel=%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD&#34;&gt;https://www.youtube.com/watch?v=Vi0hauJemxA&amp;amp;ab_channel=%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yaboong.github.io/java/2018/05/26/java-memory-management/&#34;&gt;https://yaboong.github.io/java/2018/05/26/java-memory-management/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp#l537&#34;&gt;http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/tip/src/share/vm/runtime/synchronizer.cpp#l537&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

        
      </description>
    </item>
    
    <item>
      <title>[LeetCode] Top K Frequent Elements</title>
      <link>https://sangwoncoco.github.io/post/leetcode/20210115-leetcode-347-top-k-frequent-elements/</link>
      <pubDate>Fri, 15 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://sangwoncoco.github.io/post/leetcode/20210115-leetcode-347-top-k-frequent-elements/</guid>
      <description>
        
          &lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;항목&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;플랫폼&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;LeetCode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;번호&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;347&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;제목&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Top K Frequent Elements&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;유형&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Hash, Heap&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;바로가기&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://leetcode.com/problems/top-k-frequent-elements/&#34;&gt;LINK&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;문제&#34;&gt;문제&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume k is always valid, 1 ≤ k ≤ number of unique elements.&lt;/li&gt;
&lt;li&gt;Your algorithm&#39;s time complexity must be better than O(n log n), where n is the array&#39;s size.&lt;/li&gt;
&lt;li&gt;It&#39;s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.&lt;/li&gt;
&lt;li&gt;You can return the answer in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;기본-테스트-케이스&#34;&gt;기본 테스트 케이스&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;Input: nums = [1,1,1,2,2,3], k = 2
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;Output: [1,2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Exapmle 2:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;Input: nums = [1], k = 1
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;Output: [1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h2 id=&#34;주어진-코드-스니펫&#34;&gt;주어진 코드 스니펫&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;2&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;topKFrequent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;3&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;4&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;핵심-아이디어&#34;&gt;핵심 아이디어&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;저는 이 문제를 시간 복잡도 O(n)으로 해결하기 위해 두 개의 HashMap을 사용하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sangwoncoco.github.io/images/leetcode/20210115-leetcode-347/347.png&#34; alt=&#34;Top K Frequent Elements&#34;&gt;&lt;/p&gt;
&lt;p&gt;사용한 HashMap의 의미는 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;HashMap&amp;lt;Integer, Integer&amp;gt; keyIsEle&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;key: nums 배열 내의 고유한 값&lt;/li&gt;
&lt;li&gt;value: 고유한 값이 nums 배열 내에서 등장한 횟수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HashMap&amp;lt;Integer, ArrayList&lt;Integer&gt;&amp;gt; keyIsCnt&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;key: keyIsEle의 value (nums 배열 내에서 등장한 고유한 값의 등장 횟수)&lt;/li&gt;
&lt;li&gt;value: keyIsEle에서 같은 value를 가진 key들을 연결리스트 형태로 묶은 집합&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HashMap의 의미를 파악했으니 예시를 살펴보며 1번 프로세스(nums -&amp;gt; keyIsEle)와 2번 프로세스(keyIsEle -&amp;gt; keyIsCnt)를 통해 nums 배열을 keyIsEle와 keyIsCnt로 가공한 후 답까지 도출해 봅시다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;예시에 사용되는 nums, k&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;nums = {1, 1, 1, 2, 2, 2, 3}&lt;/li&gt;
&lt;li&gt;k = 2&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;1번 프로세스 (nums -&amp;gt; keyIsEle)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;nums 배열 내에 고유한 수는 1, 2, 3 총 3개 입니다.&lt;/li&gt;
&lt;li&gt;고유한 수 1은 3번 등장합니다.&lt;/li&gt;
&lt;li&gt;고유한 수 2는 3번 등장합니다.&lt;/li&gt;
&lt;li&gt;고유한 수 3은 1번 등장합니다.&lt;/li&gt;
&lt;li&gt;그럼으로 nums 배열을 keyIsEle로 가공한 결과를 아래 표로 나타낼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;keyIsEle&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;key&lt;/strong&gt; (Integer)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;value&lt;/strong&gt; (Integer)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;2번 프로세스 (keyIsEle -&amp;gt; keyIsCnt)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;keyIsEle에서 3번 등장한 고유한 수는 1, 2 입니다.&lt;/li&gt;
&lt;li&gt;kyeIsEle에서 1번 등장한 고유한 수는 3 입니다.&lt;/li&gt;
&lt;li&gt;그럼으로 keyIsEle을 KeyIsCnt로 가공한 결과를 아래 표로 나타낼 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;keyIsCnt&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;key&lt;/strong&gt; (Integer)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;value&lt;/strong&gt; (ArrayList&lt;Integer&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;{1, 2}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;{3}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;keyIsCnt로 부터 답을 도출 해낸다!!&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;nums 배열을 시작으로 keyIsCnt까지 도출해낸 이유는 당연하게도 답을 구하기 위함 입니다.&lt;/li&gt;
&lt;li&gt;그러면 어떻게 keyIsCnt로 부터 답을 도출할 수 있을까요? 같이 알아가 봅시다.&lt;/li&gt;
&lt;li&gt;문제에서 요구하는 것은 nums 배열 내에서 자주 등장하는 고유한 수 k개를 배열로 묶어서 리턴 하는 겁니다.&lt;/li&gt;
&lt;li&gt;그리고 저희는 keyIsCnt를 알고 있으니 여기에 가장 큰 key값에 대응되는 value를 가져와 리턴할 배열에 넣어주기만 하면 됩니다.&lt;/li&gt;
&lt;li&gt;그러나 keyIsCnt는 HashMap 자료구조이고 HashMap으로 부터 value를 가져오기 위해서는 key값을 get() 메서드의 인자로 넣어주어야 하죠?&lt;/li&gt;
&lt;li&gt;어떤 수를 차례대로 get() 메서드의 인자로 넣어줘야 할까요?&lt;/li&gt;
&lt;li&gt;당연하게도 가장 많이 등장한 원소의 횟수부터 key 값으로 집어 넣어 k개 만큼의 고유한 원소를 찾으면 됩니다.&lt;/li&gt;
&lt;li&gt;근데 저희는 가장 많이 등장한 원소의 횟수를 알지 못하잖아요?&lt;/li&gt;
&lt;li&gt;물론 1, 2번 프로세스를 수행하며 가장 많이 등장한 원소의 횟수를 구할 수도 있었지만 사고의 전환을 위해 다른 방식을 설명해보겠습니다.&lt;/li&gt;
&lt;li&gt;아래 3가지 패턴을 살펴봅시다.&lt;/li&gt;
&lt;li&gt;패턴 1) nums 배열이 {1, 1, 1, 1, 1} 이라고 가정해봅시다.
&lt;ul&gt;
&lt;li&gt;이때 배열의 길이는 5입니다.&lt;/li&gt;
&lt;li&gt;배열 내의 고유한 원소 1 밖에 없습니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 1은 5번 등장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;패턴 2) nums 배열이 {1, 1, 1, 1, 2} 이라고 가정해봅시다.
&lt;ul&gt;
&lt;li&gt;이때 배열의 길이는 5입니다.&lt;/li&gt;
&lt;li&gt;배열 내의 고유한 원소는 1, 2 두 가지 입니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 1은 4번 등장합니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 2는 1번 등장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;패턴 3) nums 배열이 {1, 1, 1, 2, 3} 이라고 가정해봅시다.
&lt;ul&gt;
&lt;li&gt;이때 배열의 길이는 5입니다.&lt;/li&gt;
&lt;li&gt;배열 내의 고유한 원소는 1, 2, 3 세 가지 입니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 1은 3번 등장합니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 2은 1번 등장합니다.&lt;/li&gt;
&lt;li&gt;고유한 원소 3은 1번 등장합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;패턴이 보이시나요? 위 패턴으로 부터 얻을 수 있는 결론은 &lt;strong&gt;&amp;quot;배열 내의 특정 고유 원소를 a라고 가정할 때 a가 등장하는 횟수는 배열의 길이 n을 넘을 수 없다.&amp;quot;&lt;/strong&gt; 입니다.&lt;/li&gt;
&lt;li&gt;그러므로 저희는 최댓값을 배열의 길이 n으로 가정하고 n을 시작으로 1씩 차감하며 키값이 존재하는지 혹은 존재하지 않는지 조사한 후 만약 존재한다면 해당하는 value값을 가져와 리턴할 배열에 넣어주기만 하면 됩니다.&lt;/li&gt;
&lt;li&gt;주의할 점은 n부터 1씩 차감하는 반복문을 리턴할 원소 k개를 찾을 때까지만 수행해야 한다는 겁니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;구현-코드&#34;&gt;구현 코드&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;ln&#34;&gt; 1&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 2&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 3&lt;/span&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 4&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 5&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Solution&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 6&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;topKFrequent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 7&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 8&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIsEle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt; 9&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;10&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// nums -&amp;gt; keyIsEle
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// O(n)
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;13&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;keyIsEle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIsEle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getOrDefault&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;14&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;15&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;16&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// keyIsEle -&amp;gt; keyIsCnt
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// O(n)        
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIsEle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;entrySet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;19&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;20&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;21&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;22&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;valuelist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;23&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;valuelist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;24&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pair&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;valuelist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;25&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;26&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;27&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;28&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 배열의 길이부터 1씩 감소시키며 keyIsCnt에 해당 값을 key값으로 가지고 있는지 확인
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;29&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 최악의 경우 O(n)의 시간 복잡도
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cnt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nums&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;31&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;retlist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;32&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;33&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;34&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIsCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;35&lt;/span&gt;                &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;36&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;37&lt;/span&gt;                    &lt;span class=&#34;n&#34;&gt;retlist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;38&lt;/span&gt;                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;    
&lt;span class=&#34;ln&#34;&gt;39&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;40&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;cnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;41&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;42&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;43&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 리턴할 배열 만들어주기        
&lt;/span&gt;&lt;span class=&#34;ln&#34;&gt;44&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;retlist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()];&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;45&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;46&lt;/span&gt;            &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;retlist&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;47&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;48&lt;/span&gt;        
&lt;span class=&#34;ln&#34;&gt;49&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;50&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;ln&#34;&gt;51&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br/&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;h3 id=&#34;후기&#34;&gt;후기&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Medium 수준의 문제였지만 2개의 HashMap을 사용하여 주어진 데이터를 어떻게 가공해야 할지만 잘 정의한다면 어렵지 않게 시간 복잡도 O(n)으로 해결할 수 있었습니다.&lt;/li&gt;
&lt;li&gt;글에서 제시한 솔루션 외에도 리트코드에선 Quick Select과 Heap을 활용한 솔루션도 제공하니 시간이 충분하다면 다른 두 접근법으로 문제를 풀어보는 것도 추천합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
